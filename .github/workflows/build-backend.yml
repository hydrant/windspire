# Backend Build and Deployment
#
# Builds and deploys the backend API to Azure Functions (Custom Handlers)
# - Only runs on tagged releases for controlled deployments
# - Focuses purely on building and deploying artifacts (no quality checks)
# - Depends on infrastructure pipeline to provide deployment targets
#
# DEPENDENCY: Requires build-infrastructure.yml to run first and set Azure resources

name: Backend Build

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      function-app-name:
        required: true
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      AZURE_CLIENT_SECRET:
        required: true

env:
  CARGO_TERM_COLOR: always

jobs:
  # Build job - creates production artifacts
  build_backend:
    runs-on: ubuntu-latest
    name: Build Backend
    environment: ${{ inputs.environment }}
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: windspire
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    defaults:
      run:
        working-directory: windspire_backend
    outputs:
      environment: ${{ inputs.environment }}
    steps:
      - uses: actions/checkout@v4

      # Set up Rust with musl target for static linking
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-musl

      # Install musl development tools for cross-compilation
      - name: Install musl tools
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev pkg-config libssl-dev

      # Cache dependencies for faster builds
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            windspire_backend/target/
          key: ${{ runner.os }}-cargo-release-${{ hashFiles('windspire_backend/**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-
            ${{ runner.os }}-cargo-

      # Install SQLx CLI and prepare query cache
      - name: Install SQLx CLI
        run: |
          # Check if sqlx is already installed, if not install it
          if ! command -v sqlx &> /dev/null; then
            cargo install sqlx-cli --no-default-features --features rustls,postgres
          else
            echo "SQLx CLI already installed: $(sqlx --version)"
          fi

      # Run migrations and prepare SQLx query cache
      - name: Prepare SQLx cache
        run: |
          # Set up database connection for cache generation
          export DATABASE_URL="postgresql://test_user:test_password@localhost:5432/windspire"
          
          # Run migrations to set up database schema
          sqlx migrate run
          
          # Generate SQLx query cache
          cargo sqlx prepare
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/windspire

      # Build for production with static linking
      - name: Build for production
        run: |
          cargo build --release --target x86_64-unknown-linux-musl
          ls -la target/x86_64-unknown-linux-musl/release/
        env:
          # Use SQLx offline mode with prepared cache
          SQLX_OFFLINE: true
          DATABASE_URL: postgresql://placeholder:placeholder@localhost:5432/placeholder

      # Prepare Azure Functions Custom Handler structure
      - name: Prepare Custom Handler for Azure Functions
        run: |
          # Create Azure Functions custom handler structure
          mkdir -p function_app
          
          # Copy the Rust binary
          cp target/x86_64-unknown-linux-musl/release/windspire_backend function_app/
          chmod +x function_app/windspire_backend
          
          # Create host.json for custom handler
          cat > function_app/host.json << 'EOF'
          {
            "version": "2.0",
            "customHandler": {
              "description": {
                "defaultExecutablePath": "windspire_backend",
                "workingDirectory": "",
                "arguments": []
              },
              "enableForwardingHttpRequest": true
            },
            "extensionBundle": {
              "id": "Microsoft.Azure.Functions.ExtensionBundle",
              "version": "[2.*, 3.0.0)"
            }
          }
          EOF
          
          # Create function.json for HTTP trigger
          mkdir -p function_app/api
          cat > function_app/api/function.json << 'EOF'
          {
            "bindings": [
              {
                "authLevel": "anonymous",
                "type": "httpTrigger",
                "direction": "in",
                "name": "req",
                "methods": ["get", "post", "put", "delete", "patch", "options"],
                "route": "{*restOfPath}"
              },
              {
                "type": "http",
                "direction": "out",
                "name": "res"
              }
            ]
          }
          EOF
          
          # Copy .funcignore if it exists
          if [ -f .funcignore ]; then
            cp .funcignore function_app/
          fi
          
          echo "ðŸ“Š Custom Handler Structure:"
          ls -la function_app/
          echo ""
          echo "ðŸ”§ host.json content:"
          cat function_app/host.json
          echo ""
          echo "âš¡ Function configuration:"
          cat function_app/api/function.json
          echo ""
          echo "ðŸš€ Ready for Azure Functions custom handler deployment"

      # Upload build artifacts for deployment
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-function-${{ inputs.environment }}
          path: windspire_backend/function_app/
          retention-days: 7

  # Deploy job - deploy custom handler to Azure Functions
  deploy_backend:
    needs: build_backend
    runs-on: ubuntu-latest
    name: Deploy Backend to Function App
    environment: ${{ inputs.environment }}
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-function-${{ inputs.environment }}
          path: ./function_app

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      - name: Deploy to Azure Functions
        uses: Azure/functions-action@v1
        with:
          app-name: ${{ inputs.function-app-name }}
          package: './function_app'
          
      # Verify deployment
      - name: Verify deployment
        run: |
          echo "âœ… Backend deployed successfully!"
          echo "ðŸŒ Environment: ${{ inputs.environment }}"
          echo "ðŸ”§ Function App: ${{ inputs.function-app-name }}"
          echo "ðŸ“¡ API Endpoint: https://${{ inputs.function-app-name }}.azurewebsites.net/api"
          echo ""
          echo "â³ Waiting 45 seconds for Function App to fully start with new environment..."
          sleep 45
          echo ""
          echo "ðŸ” Testing API health endpoint..."
          
          # Test health endpoint with detailed output
          echo "Testing: https://${{ inputs.function-app-name }}.azurewebsites.net/api/health"
          HTTP_STATUS=$(curl -o /dev/null -s -w "%{http_code}" https://${{ inputs.function-app-name }}.azurewebsites.net/api/health)
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… Health check passed (HTTP $HTTP_STATUS)"
            echo "ðŸŽ‰ Backend is healthy and responding!"
          else
            echo "âŒ Health check failed (HTTP $HTTP_STATUS)"
            echo "â„¹ï¸  This may be normal during initial deployment or if the backend needs time to start"
            echo "ï¿½ Next steps: Check the Function App logs in Azure Portal for detailed error information"
          fi