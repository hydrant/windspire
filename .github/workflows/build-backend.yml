# Backend Build and Deployment - Container Apps
#
# This workflow builds the Rust backend as a Docker container and deploys it to Azure Container Apps.
# 
# Key steps:
# 1. Run SQLx preparation to verify offline mode works
# 2. Build Docker image using multi-stage Dockerfile (rust:alpine ‚Üí scratch)
# 3. Push image to Azure Container Registry
# 4. Update Container App with new image revision
#
# DEPENDENCIES: 
# - Infrastructure pipeline must run first to create Container App and ACR
#
# Uses GitHub secrets (from Entra App Registration):
# - AZURE_CLIENT_ID: Service principal client ID (see infrastructure/SETUP.md)
# - AZURE_TENANT_ID: Azure AD tenant ID
# - AZURE_SUBSCRIPTION_ID: Azure subscription ID
# - AZURE_CLIENT_SECRET: Service principal secret

name: Backend Build (Container Apps)

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      container-app-name:
        description: 'Name of the Container App to deploy to'
        required: true
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      AZURE_CLIENT_SECRET:
        required: true
      AZURE_RESOURCE_GROUP:
        required: true

env:
  CARGO_TERM_COLOR: always
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Build and push Docker image
  build_and_push:
    runs-on: ubuntu-latest
    name: Build & Push Container Image
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Verify SQLx offline mode before building Docker image
      # This ensures the SQLx query cache is up-to-date
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-musl

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev postgresql-client
          cargo install sqlx-cli --no-default-features --features postgres

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            windspire_backend/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('windspire_backend/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # Set up PostgreSQL for SQLx cache verification
      - name: Start PostgreSQL
        run: |
          docker run -d \
            --name postgres \
            -e POSTGRES_PASSWORD=test_password \
            -e POSTGRES_USER=test_user \
            -e POSTGRES_DB=windspire \
            -p 5432:5432 \
            postgres:16
          
          # Wait for PostgreSQL to be ready
          for i in {1..30}; do
            if docker exec postgres pg_isready -U test_user; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done

      # Generate SQLx query cache for offline mode (if not committed)
      - name: Generate SQLx query cache
        working-directory: windspire_backend
        run: |
          export DATABASE_URL="postgresql://test_user:test_password@localhost:5432/windspire"
          
          # Run migrations
          echo "üîÑ Running database migrations..."
          sqlx migrate run
          
          # Generate SQLx query cache (creates .sqlx directory if missing)
          echo "üîç Generating SQLx query cache..."
          if [ -d ".sqlx" ]; then
            echo "‚ÑπÔ∏è  .sqlx cache already exists (committed to repo)"
            cargo sqlx prepare --check || cargo sqlx prepare
          else
            echo "‚ö†Ô∏è  .sqlx cache missing - generating it now"
            cargo sqlx prepare
            echo "üí° TIP: Commit .sqlx directory to speed up future builds"
          fi
          
          echo "‚úÖ SQLx query cache ready - proceeding with Docker build"
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/windspire

      - name: Verify SQLx cache exists
        working-directory: windspire_backend
        run: |
          echo "üìÇ Checking .sqlx directory..."
          if [ -d ".sqlx" ]; then
            echo "‚úÖ .sqlx directory found"
            echo "üìä Query cache files:"
            ls -lh .sqlx/
          else
            echo "‚ùå ERROR: .sqlx directory not found!"
            exit 1
          fi

      - name: Clean up PostgreSQL
        if: always()
        run: |
          docker stop postgres || true
          docker rm postgres || true

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build and push to GitHub Container Registry
      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v6
        with:
          context: ./windspire_backend
          file: ./windspire_backend/Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/windspire-backend:${{ env.IMAGE_TAG }}
            ghcr.io/${{ github.repository_owner }}/windspire-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Image pushed successfully
        run: |
          echo "‚úÖ Docker image built and pushed to GitHub Container Registry"
          echo "üì¶ Image: ghcr.io/${{ github.repository_owner }}/windspire-backend:${{ env.IMAGE_TAG }}"
          echo "üì¶ Image: ghcr.io/${{ github.repository_owner }}/windspire-backend:latest"

  # Deploy to Container App
  deploy:
    needs: build_and_push
    runs-on: ubuntu-latest
    name: Deploy to Container App
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      # Update Container App with new image from GHCR
      - name: Update Container App
        run: |
          echo "üöÄ Updating Container App with new image from GitHub Container Registry..."
          echo "Container App: ${{ inputs.container-app-name }}"
          echo "Image: ghcr.io/${{ github.repository_owner }}/windspire-backend:${{ env.IMAGE_TAG }}"
          
          az containerapp update \
            --name ${{ inputs.container-app-name }} \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --image ghcr.io/${{ github.repository_owner }}/windspire-backend:${{ env.IMAGE_TAG }}
          
          echo "‚úÖ Container App updated successfully"

      # Wait for deployment and verify health
      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting for Container App to start with new image..."
          sleep 30
          
          # Get Container App URL
          CONTAINER_APP_URL=$(az containerapp show \
            --name ${{ inputs.container-app-name }} \
            --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)
          
          echo "üåê Container App URL: https://${CONTAINER_APP_URL}"
          
          # Test health endpoint
          echo "üîç Testing health endpoint..."
          HTTP_STATUS=$(curl -o /dev/null -s -w "%{http_code}" "https://${CONTAINER_APP_URL}/health" || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $HTTP_STATUS)"
            echo "üéâ Backend is healthy and responding!"
          else
            echo "‚ö†Ô∏è  Health check returned HTTP $HTTP_STATUS"
            echo "‚ÑπÔ∏è  This may be normal if the app is still starting or scaling from zero"
            echo "üí° Check Container App logs: az containerapp logs show --name ${{ inputs.container-app-name }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }}"
          fi
          
          echo ""
          echo "‚úÖ Deployment Summary:"
          echo "   - Environment: ${{ inputs.environment }}"
          echo "   - Container App: ${{ inputs.container-app-name }}"
          echo "   - Image: ghcr.io/${{ github.repository_owner }}/windspire-backend:${{ env.IMAGE_TAG }}"
          echo "   - URL: https://${CONTAINER_APP_URL}"
          echo "   - API Endpoint: https://${CONTAINER_APP_URL}/api"
