# Backend Build and Deployment - Container Apps
#
# This workflow builds the Rust backend as a Docker container and deploys it to Azure Container Apps.
# 
# Key steps:
# 1. Run SQLx preparation to verify offline mode works
# 2. Build Docker image using multi-stage Dockerfile (rust:alpine ‚Üí scratch)
# 3. Push image to Azure Container Registry
# 4. Update Container App with new image revision
#
# DEPENDENCIES: 
# - Infrastructure pipeline must run first to create Container App and ACR
#
# Uses GitHub secrets (from Entra App Registration):
# - AZURE_CLIENT_ID: Service principal client ID (see infrastructure/SETUP.md)
# - AZURE_TENANT_ID: Azure AD tenant ID
# - AZURE_SUBSCRIPTION_ID: Azure subscription ID
# - AZURE_CLIENT_SECRET: Service principal secret

name: Backend Build (Container Apps)

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: string
      container-app-name:
        description: 'Name of the Container App to deploy to'
        required: true
        type: string
      registry-name:
        description: 'Name of the Azure Container Registry'
        required: true
        type: string
      registry-login-server:
        description: 'Login server URL for the Container Registry'
        required: true
        type: string
      resource-group:
        description: 'Azure resource group name'
        required: true
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      AZURE_CLIENT_SECRET:
        required: true
      AZURE_RESOURCE_GROUP:
        required: true

env:
  CARGO_TERM_COLOR: always
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Build and push Docker image
  build_and_push:
    runs-on: ubuntu-latest
    name: Build & Push Container Image
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Verify SQLx offline mode before building Docker image
      # This ensures the SQLx query cache is up-to-date
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-musl

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev postgresql-client
          cargo install sqlx-cli --no-default-features --features postgres

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            windspire_backend/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('windspire_backend/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # Set up PostgreSQL for SQLx cache verification
      - name: Start PostgreSQL
        run: |
          docker run -d \
            --name postgres \
            -e POSTGRES_PASSWORD=test_password \
            -e POSTGRES_USER=test_user \
            -e POSTGRES_DB=windspire \
            -p 5432:5432 \
            postgres:16
          
          # Wait for PostgreSQL to be ready
          for i in {1..30}; do
            if docker exec postgres pg_isready -U test_user; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done

      # Verify SQLx offline mode works
      - name: Verify SQLx offline mode
        working-directory: windspire_backend
        run: |
          export DATABASE_URL="postgresql://test_user:test_password@localhost:5432/windspire"
          
          # Run migrations
          echo "üîÑ Running database migrations..."
          sqlx migrate run
          
          # Verify SQLx query cache exists and is current
          echo "üîç Verifying SQLx query cache..."
          cargo sqlx prepare --check
          
          echo "‚úÖ SQLx offline mode verified - ready for Docker build"
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/windspire

      - name: Clean up PostgreSQL
        if: always()
        run: |
          docker stop postgres || true
          docker rm postgres || true

      # Azure Login for ACR access
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      # Build and push using Azure Container Registry build
      # This builds the image in Azure, avoiding local Docker complexity
      - name: Build and push Docker image to ACR
        working-directory: windspire_backend
        run: |
          echo "üèóÔ∏è  Building Docker image in Azure Container Registry..."
          echo "Registry: ${{ inputs.registry-name }}"
          echo "Image: windspire-backend:${{ env.IMAGE_TAG }}"
          
          az acr build \
            --registry ${{ inputs.registry-name }} \
            --image windspire-backend:${{ env.IMAGE_TAG }} \
            --image windspire-backend:latest \
            --file Dockerfile \
            --platform linux/amd64 \
            .
          
          echo "‚úÖ Docker image built and pushed successfully"

  # Deploy to Container App
  deploy:
    needs: build_and_push
    runs-on: ubuntu-latest
    name: Deploy to Container App
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'

      # Update Container App with new image
      - name: Update Container App
        run: |
          echo "üöÄ Updating Container App with new image..."
          echo "Container App: ${{ inputs.container-app-name }}"
          echo "Image: ${{ inputs.registry-login-server }}/windspire-backend:${{ env.IMAGE_TAG }}"
          
          az containerapp update \
            --name ${{ inputs.container-app-name }} \
            --resource-group ${{ inputs.resource-group }} \
            --image ${{ inputs.registry-login-server }}/windspire-backend:${{ env.IMAGE_TAG }}
          
          echo "‚úÖ Container App updated successfully"

      # Wait for deployment and verify health
      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting for Container App to start with new image..."
          sleep 30
          
          # Get Container App URL
          CONTAINER_APP_URL=$(az containerapp show \
            --name ${{ inputs.container-app-name }} \
            --resource-group ${{ inputs.resource-group }} \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)
          
          echo "üåê Container App URL: https://${CONTAINER_APP_URL}"
          
          # Test health endpoint
          echo "üîç Testing health endpoint..."
          HTTP_STATUS=$(curl -o /dev/null -s -w "%{http_code}" "https://${CONTAINER_APP_URL}/health" || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Health check passed (HTTP $HTTP_STATUS)"
            echo "üéâ Backend is healthy and responding!"
          else
            echo "‚ö†Ô∏è  Health check returned HTTP $HTTP_STATUS"
            echo "‚ÑπÔ∏è  This may be normal if the app is still starting or scaling from zero"
            echo "üí° Check Container App logs: az containerapp logs show --name ${{ inputs.container-app-name }} --resource-group ${{ inputs.resource-group }}"
          fi
          
          echo ""
          echo "‚úÖ Deployment Summary:"
          echo "   - Environment: ${{ inputs.environment }}"
          echo "   - Container App: ${{ inputs.container-app-name }}"
          echo "   - Image: windspire-backend:${{ env.IMAGE_TAG }}"
          echo "   - URL: https://${CONTAINER_APP_URL}"
          echo "   - API Endpoint: https://${CONTAINER_APP_URL}/api"
